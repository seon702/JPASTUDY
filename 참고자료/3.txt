JPA 영속성 컨텍스트
p5
고객의 요청에 따라 엔티티메니저 생성
p6
영속성 컨텍스트
- jpa를 이해하는데 가장 중요한 용어
- 엔티티를 영구저장하는 환경이라는 뜻
- EntityManager.persist(entity);
- 영속성 컨텍스트를 통해 영속화한다. 엔티티를 영속성 컨텍스트에 저장

p7
눈에 보이지 않고 영속성 컨텍스트는 노닐적 개념
- 엔티티 매니저를 통해 영속성 컨텍스트에 접근

p8

p9
엔티티의 생명주기
비영속(new/transient)
영속성 컨텍스트와 관계없는 새로운 상태

영속(managed)
영속성 컨텍스트에 관리되는 상태

준영속(detached)
저장되었다 분리된 상태

p11
jpa와 관계어벗는
//객체를 생성한 상태(비영속)
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");

p12
//객체를 생성한 상태(비영속)
Member member = new Member();
member.setId("member1");
member.setUsername(“회원1”);
EntityManager em = emf.createEntityManager();
em.getTransaction().begin();
//객체를 저장한 상태(영속)
em.persist(member);

p15
1차캐시 이게 영속성 컨텍스트라 생각해도 된다

p16
DB가 아닌 1차 캐시에서 찾는다.

p17
1차 캐시에서 찾는데 없으면 DB에서 조회.
DB에 있는 내용을 1차 캐시에 저장. 

짧은 순간에서만 이득... 여러명의 고객이 사용하는 캐시가 아님.(그런건 2차 캐시)
성능보다는 매커니즘적으로 얻을 수있는 이점이 있ㄷ음

p18
영속 엔티티의 동일성 보장

p19~21
em.persist(memberA);
em.persist(memberB);
여기까지에서는 SQL을 데이터베이스에 보내지 않고

transaction.commit();
커밋 하는 순간 데이터베이스로 보내진다.

            <property name="hibernate.jdbc.batch_size" value="10"/>
모았다가 한번에 보내진다.
버퍼링을 모았다가 보낸다.

p22~23
jpa는 데이터베이터 커밋하는 시점에서 flush()가 호출됨
그 후 엔티티와 스냅샷을 비교. 변경되면 감지함

p25
플러시
영속성 켄텍스트의 변경내용을 데이터베이스에 반영

p26
플러시가 발생하면
-변경감지
-수정된 엔티티를 쓰기지연 저장소에 등록
-저장소에 있는 쿼리를 DB에 전송

p27
영속성 컨텍스트를 플러시하는 방법
em.flush() 직접호출
트랜잭션 커밋 - 플러시자동호출
JPQL쿼리 실행 플러시 자동호출

플러시를 호출한다고 1차캐시가 지워지거나 하지는 않는다.
쓰기 지연 저장소에 있는 내용들이 데이터베이스에 반영이 되는 과정

p28
JPQL 쿼리 실행시 플러시가 자동으로 호출되는 이유
오류 방지하기 위해

P29
그냥 모드 기본 되어있는 오토를 써라

p30
영속성 컨텍스트를 비우지 않음
영속성 컨텍스트의 변경내용을 데이터베이스에 동기화
트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화하면 됨

p31
준영속 상태

영속 상태의 엔티티가 영속성 컨텍스트에서 분리

준영속 상태로 만드는 방법
em.detach(entity) - 특정 엔티티만 준영속 상태로 전환
em.clear() - 영속성 컨텍스트를 완전히 초기화
em.close() - 영속성 컨텍스트를 종료

